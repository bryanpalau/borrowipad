<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>iPad Express Checkout</title>

  <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>

  <style>
    :root{
      --primary:#4f46e5;
      --success:#10b981;
      --bg:#0f172a;
      --panel:#1e293b;
      --danger:#ef4444;
      --gray:#334155;
      --warning:#f59e0b;
      --vh:1vh;
    }

    *{ box-sizing:border-box; }

    body{
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      color:#fff;
      margin:0;
      display:flex;
      flex-direction:column;
      height:calc(var(--vh) * 100);
      overflow:hidden;
      -webkit-user-select:none;
      -webkit-tap-highlight-color:transparent;
    }

    .header{
      padding:10px;
      background:var(--panel);
      border-bottom:1px solid var(--gray);
      flex-shrink:0;
    }

    .mode-toggle{
      display:flex;
      background:#0f172a;
      border-radius:10px;
      padding:4px;
      margin:0 auto;
      width:min(520px, 100%);
    }

    .mode-btn{
      flex:1;
      padding:12px;
      border:none;
      border-radius:8px;
      color:#94a3b8;
      background:none;
      font-size:1.05rem;
      font-weight:800;
      cursor:pointer;
      transition:0.2s;
    }

    .mode-btn.active{
      background:var(--primary);
      color:#fff;
    }

    #reader-container{
      width:min(560px, 100%);
      margin:10px auto 0;
      padding:0 12px;
      position:relative;
      flex-shrink:0;
    }

    #reader{
      width:100% !important;
      height:clamp(220px, 38vh, 360px) !important;
      background:#000;
      border-radius:14px;
      overflow:hidden;
      border:2px solid var(--gray);
      position:relative;
    }

    #reader video{
      width:100% !important;
      height:100% !important;
      object-fit:cover !important;
    }

    .scan-overlay{
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%, -50%);
      width:min(260px, 72vw);
      height:min(260px, 72vw);
      max-width:260px;
      max-height:260px;
      border:3px solid var(--success);
      border-radius:14px;
      pointer-events:none;
      opacity:0.55;
      animation:pulse 2s infinite;
    }

    @keyframes pulse{
      0%,100%{ opacity:0.55; }
      50%{ opacity:0.25; }
    }

    .scan-corner{
      position:absolute;
      width:30px;
      height:30px;
      border:3px solid var(--success);
    }
    .scan-corner.tl{ top:0; left:0; border-right:none; border-bottom:none; }
    .scan-corner.tr{ top:0; right:0; border-left:none; border-bottom:none; }
    .scan-corner.bl{ bottom:0; left:0; border-right:none; border-top:none; }
    .scan-corner.br{ bottom:0; right:0; border-left:none; border-top:none; }

    .start-overlay{
      position:absolute;
      inset:0 12px 0 12px;
      top:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgba(15,23,42,0.65);
      border-radius:14px;
      z-index:5;
      height:clamp(220px, 38vh, 360px);
      pointer-events:auto;
    }

    .start-btn{
      border:none;
      border-radius:14px;
      padding:14px 18px;
      font-weight:900;
      font-size:1rem;
      color:#fff;
      background:var(--primary);
      cursor:pointer;
      box-shadow:0 10px 25px rgba(0,0,0,0.35);
    }

    .start-btn:active{
      opacity:0.85;
      transform:scale(0.98);
    }

    .overlay{
      padding:16px;
      background:var(--panel);
      border-radius:24px 24px 0 0;
      box-shadow:0 -5px 20px rgba(0,0,0,0.5);
      flex:1;
      display:flex;
      flex-direction:column;
      overflow:hidden;
      width:min(900px, 100%);
      margin:0 auto;
    }

    #userPanel{
      display:none;
      justify-content:space-between;
      gap:10px;
      padding:12px;
      background:#0f172a;
      border-radius:10px;
      margin-bottom:10px;
      border-left:4px solid var(--primary);
      flex-shrink:0;
      align-items:center;
    }

    .status-banner{
      text-align:center;
      padding:14px;
      border-radius:10px;
      font-weight:900;
      margin-bottom:10px;
      flex-shrink:0;
      font-size:0.95rem;
      user-select:none;
    }

    .status-waiting{ background:var(--gray); color:#cbd5e1; }
    .status-success{ background:var(--success); color:#fff; border:2px solid #6ee7b7; }
    .status-error{ background:var(--danger); color:#fff; }
    .status-warning{ background:var(--warning); color:#fff; }

    #historyList{
      flex:1;
      overflow:auto;
      background:#0f172a;
      border-radius:12px;
      margin-bottom:12px;
      border:1px solid var(--gray);
      display:none;
    }

    .history-row{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:12px;
      border-bottom:1px solid #334155;
    }

    .history-label{
      font-weight:900;
      letter-spacing:1px;
      color:#e2e8f0;
    }

    .action-bar{
      display:grid;
      grid-template-columns:1fr 1fr 1fr;
      gap:10px;
      height:56px;
      flex-shrink:0;
    }

    .btn-action{
      border-radius:12px;
      border:none;
      background:var(--gray);
      color:#fff;
      font-size:1rem;
      font-weight:900;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      transition:0.2s;
      min-height:44px;
    }

    .btn-finish{ background:var(--primary); }
    .btn-clear{ background:#475569; }

    .btn-action:active{
      opacity:0.7;
      transform:scale(0.98);
    }

    .btn-finish:disabled{
      opacity:0.5;
      cursor:not-allowed;
    }

    .delete-btn{
      background:rgba(239,68,68,0.2);
      color:#ff8080;
      border:1px solid var(--danger);
      padding:8px 12px;
      border-radius:10px;
      font-weight:900;
      font-size:0.8rem;
      cursor:pointer;
    }

    @media (max-width:480px){
      .overlay{ padding:14px; }
      .mode-btn{ font-size:0.95rem; padding:10px; }
      .action-bar{ gap:8px; height:52px; }
      .btn-action{ font-size:0.9rem; }
      .scan-overlay{ border-width:2px; }
    }
  </style>
</head>

<body>
  <div class="header">
    <div class="mode-toggle">
      <button id="btnBorrow" class="mode-btn active" onclick="setMode('borrow')">BORROW</button>
      <button id="btnReturn" class="mode-btn" onclick="setMode('return')">RETURN</button>
    </div>
  </div>

  <div id="reader-container">
    <div id="reader"></div>

    <div class="scan-overlay">
      <div class="scan-corner tl"></div>
      <div class="scan-corner tr"></div>
      <div class="scan-corner bl"></div>
      <div class="scan-corner br"></div>
    </div>

    <div id="startOverlay" class="start-overlay">
      <button class="start-btn" onclick="userStart()">Tap to Start Scanning</button>
    </div>
  </div>

  <div class="overlay">
    <div id="userPanel">
      <div>User: <b id="currentUserId" style="color:var(--primary)">-</b></div>
      <div id="sessionCount">Qty: 0</div>
    </div>

    <div id="statusBanner" class="status-banner status-waiting">TAP TO START</div>

    <div id="historyList"></div>

    <div class="action-bar">
      <button class="btn-action btn-clear" onclick="clearAll()">Clear All</button>
      <button class="btn-action" onclick="toggleHistory()">Review</button>
      <button id="finishBtn" class="btn-action btn-finish" onclick="finishSession()">Finish & Save</button>
    </div>
  </div>

  <script>
    const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbwZm7QVUiNBVNOjc9VBhXf8UcTxgt5oPXldRdzeS2X1SjAxKjmk5GmxPoM7jVa7RHBy/exec";
    const DEBUG_MODE = false;

    let mode = "borrow";
    let userId = null;
    let sessionHistory = [];
    let isProcessing = false;

    let unavailableIpads = [];
    let unavailableCacheTs = 0;

    // NEW: inventory + roster caches
    let knownIpadsSet = new Set();
    let knownUsersSet = new Set();
    let inventoryCacheTs = 0;
    let rosterCacheTs = 0;

    let lastScanned = null;
    let lastScanTime = 0;

    let html5QrCode = null;
    let scannerStarted = false;

    let audioCtx = null;

    let historyDom = new Map(); // ipadId -> element

    function log(...args){ if (DEBUG_MODE) console.log(...args); }

    function setVhUnit(){
      const vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty("--vh", `${vh}px`);
    }
    window.addEventListener("resize", setVhUnit);
    window.addEventListener("orientationchange", () => setTimeout(setVhUnit, 250));
    setVhUnit();

    function vibrate(ms){
      try{ if (navigator.vibrate) navigator.vibrate(ms); } catch(e){}
    }

    function initAudioContext(){
      try{
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === "suspended") audioCtx.resume();
      } catch(e){}
    }

    function playBeep(freq, durMs){
      try{
        initAudioContext();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.connect(g);
        g.connect(audioCtx.destination);
        o.frequency.value = freq;
        g.gain.setValueAtTime(0.12, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + durMs / 1000);
        o.start();
        o.stop(audioCtx.currentTime + durMs / 1000);
      } catch(e){}
    }

    function playError(){
      try{
        initAudioContext();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "sine";
        o.frequency.setValueAtTime(280, audioCtx.currentTime);
        o.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.25);
        o.connect(g);
        g.connect(audioCtx.destination);
        g.gain.setValueAtTime(0.12, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.25);
        o.start();
        o.stop(audioCtx.currentTime + 0.25);
      } catch(e){}
    }

    function updateBanner(text, cls){
      const b = document.getElementById("statusBanner");
      b.innerText = text;
      b.className = "status-banner " + cls;
      b.onclick = null;
      log("Banner:", text);
    }

    function makeRequestId(){
      try{
        if (crypto && crypto.randomUUID) return crypto.randomUUID();
      } catch(e){}
      return "RID_" + Date.now() + "_" + Math.random().toString(16).slice(2);
    }

    async function userStart(){
      initAudioContext();
      vibrate(20);
      document.getElementById("startOverlay").style.display = "none";
      updateBanner("STARTING CAMERA...", "status-waiting");
      await startScanner();
    }

    // UPDATED: pulls unavailable list + inventory ids + user roster ids in ONE GET
    async function syncSystemCache(retryCount = 0){
      const maxRetries = 3;
      try{
        const resp = await fetch(SCRIPT_URL, { method:"GET", cache:"no-cache" });
        if (!resp.ok) throw new Error("HTTP " + resp.status);
        const data = await resp.json();
        if (!data.success) throw new Error(data.error || "Bad response");

        // unavailable list
        unavailableIpads = (data.borrowed || [])
          .map(x => (x || "").toString().trim().toUpperCase())
          .filter(Boolean);
        unavailableCacheTs = Date.now();

        // known iPads
        const inv = (data.inventoryIds || [])
          .map(x => (x || "").toString().trim().toUpperCase())
          .filter(Boolean);
        knownIpadsSet = new Set(inv);
        inventoryCacheTs = Date.now();

        // known users
        const users = (data.userIds || [])
          .map(x => (x || "").toString().trim().toUpperCase())
          .filter(Boolean);
        knownUsersSet = new Set(users);
        rosterCacheTs = Date.now();

        updateBanner("STEP 1: SCAN USER ID", "status-waiting");
      } catch(e){
        log("Sync failed:", e);
        if (retryCount < maxRetries){
          setTimeout(() => syncSystemCache(retryCount + 1), 800 * (retryCount + 1));
        } else {
          // offline behavior: keep last cache if it exists, but still allow scanning
          const invAge = Date.now() - inventoryCacheTs;
          const userAge = Date.now() - rosterCacheTs;

          // if cache is too old, do not block, but warn
          if (invAge > 10 * 60 * 1000) knownIpadsSet = new Set();
          if (userAge > 10 * 60 * 1000) knownUsersSet = new Set();

          updateBanner("OFFLINE MODE: SCAN USER ID", "status-warning");
        }
      }
    }

    async function startScanner(){
      try{
        if (scannerStarted) return;

        html5QrCode = new Html5Qrcode("reader");

        const config = {
          fps: 8,
          qrbox: { width: 280, height: 280 },
          aspectRatio: 1.0,
          formatsToSupport: [Html5QrcodeSupportedFormats.QR_CODE]
        };

        const devices = await Html5Qrcode.getCameras();
        if (!devices || devices.length === 0) throw new Error("No camera found");

        await html5QrCode.start(
          { facingMode:"environment" },
          config,
          onScanSuccess,
          () => {}
        );

        scannerStarted = true;
        updateBanner("SYNCING STATUS...", "status-waiting");
        await syncSystemCache();
      } catch(err){
        console.error(err);
        updateBanner("CAMERA ERROR. TAP TO RETRY", "status-error");
        document.getElementById("startOverlay").style.display = "flex";
        document.getElementById("statusBanner").onclick = () => {
          document.getElementById("statusBanner").onclick = null;
          userStart();
        };
      }
    }

    async function restartScanner(){
      try{
        if (!html5QrCode) return;
        if (html5QrCode.isScanning){
          await html5QrCode.stop();
        }
        scannerStarted = false;
        await startScanner();
      } catch(e){
        log("Restart scanner failed:", e);
      }
    }

    // NEW: hard reset for iPad Safari camera stability
    async function hardResetScanner(){
      try{
        if (html5QrCode){
          if (html5QrCode.isScanning){
            await html5QrCode.stop();
          }
          html5QrCode.clear();
        }
      } catch(e){
        console.warn("Scanner stop failed", e);
      }

      html5QrCode = null;
      scannerStarted = false;

      lastScanned = null;
      lastScanTime = 0;

      await new Promise(r => setTimeout(r, 150));
      await startScanner();
    }

    window.addEventListener("orientationchange", () => setTimeout(restartScanner, 450));
    document.addEventListener("visibilitychange", () => {
      if (!document.hidden) setTimeout(restartScanner, 450);
    });

    function updateCount_(){
      document.getElementById("sessionCount").innerText = "Qty: " + sessionHistory.length;
    }

    function ensureHistoryVisible_(){
      const list = document.getElementById("historyList");
      if (list.style.display !== "block") list.style.display = "block";
    }

    function addHistoryRowBottom_(ipadId){
      const list = document.getElementById("historyList");
      ensureHistoryVisible_();

      const row = document.createElement("div");
      row.className = "history-row";

      const label = document.createElement("span");
      label.className = "history-label";
      label.textContent = ipadId;

      const btn = document.createElement("button");
      btn.className = "delete-btn";
      btn.textContent = "DELETE";
      btn.onclick = () => removeById_(ipadId);

      row.appendChild(label);
      row.appendChild(btn);

      list.appendChild(row);
      historyDom.set(ipadId, row);
      updateCount_();
    }

    function removeById_(ipadId){
      const idx = sessionHistory.indexOf(ipadId);
      if (idx >= 0) sessionHistory.splice(idx, 1);

      const el = historyDom.get(ipadId);
      if (el && el.parentNode) el.parentNode.removeChild(el);
      historyDom.delete(ipadId);

      updateCount_();
      if (sessionHistory.length === 0) {
        document.getElementById("historyList").style.display = "none";
        updateBanner("READY. SCAN NEXT IPAD", "status-waiting");
      }
    }

    function clearHistoryDom_(){
      historyDom.clear();
      const list = document.getElementById("historyList");
      list.innerHTML = "";
    }

    function onScanSuccess(decodedText){
      const now = Date.now();
      const clean = (decodedText || "").toString().trim().toUpperCase();
      if (!clean) return;

      if (clean === lastScanned && (now - lastScanTime) < 1500){
        updateBanner("DUPLICATE SCAN", "status-warning");
        playError();
        vibrate(60);
        return;
      }

      lastScanned = clean;
      lastScanTime = now;

      const userPattern = /^[ST]\d{3,}$/i;
      const ipadPattern = /^IPAD-\d{3,}$/i;

      // STEP 1: user
      if (!userId){
        if (userPattern.test(clean)){
          // NEW: reject users not in roster when cache is available
          // If cache is empty (offline), allow but server will still reject on save
          if (knownUsersSet.size > 0 && !knownUsersSet.has(clean)){
            updateBanner("USER NOT IN ROSTER", "status-error");
            playError();
            vibrate(90);
            return;
          }

          userId = clean;
          document.getElementById("userPanel").style.display = "flex";
          document.getElementById("currentUserId").innerText = userId;
          updateBanner("USER OK. NOW SCAN IPADS", "status-success");
          playBeep(900, 120);
          vibrate(25);
        } else {
          updateBanner("INVALID USER QR (S001 OR T001)", "status-error");
          playError();
          vibrate(80);
        }
        return;
      }

      // STEP 2: iPads
      if (ipadPattern.test(clean)){
        // NEW: block unknown iPads before adding
        // If inventory cache is empty (offline), do not block here, server will still reject
        if (knownIpadsSet.size > 0 && !knownIpadsSet.has(clean)){
          updateBanner("UNKNOWN IPAD ID. DO NOT USE", "status-error");
          playError();
          vibrate(100);
          return;
        }

        if (mode === "borrow" && unavailableIpads.includes(clean)){
          updateBanner("UNAVAILABLE (BORROWED OR ADMIN BLOCKED)", "status-error");
          playError();
          vibrate(90);
          return;
        }

        if (sessionHistory.includes(clean)){
          updateBanner("ALREADY IN THIS SESSION", "status-warning");
          playError();
          vibrate(60);
          return;
        }

        sessionHistory.push(clean);
        addHistoryRowBottom_(clean);

        updateBanner("ADDED " + clean, "status-success");
        playBeep(650, 90);
        vibrate(20);
        return;
      }

      updateBanner("INVALID QR CODE", "status-error");
      playError();
      vibrate(80);
    }

    // UPDATED: Clear All now hard-resets scanner to prevent iPad Safari camera lock
    async function clearAll(){
      if (sessionHistory.length === 0) return;
      if (confirm("Clear all scanned iPads and start over?")){
        sessionHistory = [];
        clearHistoryDom_();
        document.getElementById("historyList").style.display = "none";
        updateCount_();
        updateBanner("LIST CLEARED", "status-waiting");

        await hardResetScanner();
      }
    }

    function toggleHistory(){
      const l = document.getElementById("historyList");
      if (sessionHistory.length === 0) return;
      l.style.display = (l.style.display === "none" || l.style.display === "") ? "block" : "none";
    }

    function resetAll(){
      userId = null;
      sessionHistory = [];
      isProcessing = false;
      document.getElementById("finishBtn").disabled = false;
      document.getElementById("userPanel").style.display = "none";
      document.getElementById("historyList").style.display = "none";
      clearHistoryDom_();
      updateCount_();
      updateBanner("STEP 1: SCAN USER ID", "status-waiting");
    }

    function resetSessionOnly(){
      sessionHistory = [];
      isProcessing = false;
      document.getElementById("finishBtn").disabled = false;
      document.getElementById("historyList").style.display = "none";
      clearHistoryDom_();
      updateCount_();
      updateBanner("READY. SCAN NEXT IPAD", "status-waiting");
    }

    function setMode(m){
      if (isProcessing) {
        updateBanner("SAVING IN PROGRESS", "status-warning");
        return;
      }
      mode = m;
      document.getElementById("btnBorrow").classList.toggle("active", m === "borrow");
      document.getElementById("btnReturn").classList.toggle("active", m === "return");
      resetAll();
      syncSystemCache();
    }

    async function finishSession(){
      if (!userId || sessionHistory.length === 0 || isProcessing) return;

      isProcessing = true;
      document.getElementById("finishBtn").disabled = true;
      updateBanner("SAVING...", "status-warning");

      const payload = {
        action: mode,
        userId: userId,
        ipadId: sessionHistory,
        requestId: makeRequestId()
      };

      const maxRetries = 3;

      for (let attempt = 1; attempt <= maxRetries; attempt++){
        try{
          // NEW: abort after 15s to avoid iPad Safari "stuck fetch"
          const controller = new AbortController();
          const t = setTimeout(() => controller.abort(), 15000);

          const resp = await fetch(SCRIPT_URL, {
            method: "POST",
            headers: { "Content-Type": "text/plain;charset=utf-8" },
            body: JSON.stringify(payload),
            signal: controller.signal
          });

          clearTimeout(t);

          let result = null;
          try{ result = await resp.json(); } catch(e){}

          if (result && result.success){
            updateBanner("SAVED", "status-success");
            playBeep(1100, 200);
            vibrate(40);
            await syncSystemCache();
            setTimeout(resetSessionOnly, 700);
            return;
          }

          // If roster invalid or other hard errors
          if (result && (result.error || result.message) && (!result.results || result.results.length === 0)){
            const msg = (result.message || result.error || "SAVE FAILED").toString().toUpperCase();
            updateBanner(msg, "status-error");
            playError();
            vibrate(90);
            isProcessing = false;
            document.getElementById("finishBtn").disabled = false;
            return;
          }

          if (result && Array.isArray(result.results)){
            const failed = result.results.filter(r => !r.success).map(r => r.ipadId).filter(Boolean);

            if (failed.length > 0){
              sessionHistory = failed;
              clearHistoryDom_();
              for (const id of sessionHistory) addHistoryRowBottom_(id);

              isProcessing = false;
              document.getElementById("finishBtn").disabled = false;
              updateBanner("SOME FAILED. REVIEW AND RETRY", "status-warning");
              playError();
              vibrate(80);
              await syncSystemCache();
              return;
            }

            throw new Error("Save failed");
          }

          const errMsg = (result && (result.error || result.message)) ? (result.error || result.message) : ("HTTP " + resp.status);
          throw new Error(errMsg);

        } catch(err){
          log("Save attempt failed:", attempt, err);

          if (attempt < maxRetries){
            updateBanner("RETRYING " + attempt + " OF " + maxRetries, "status-warning");
            await new Promise(r => setTimeout(r, 700 * attempt));
          } else {
            playError();
            vibrate(90);
            updateBanner("SAVE FAILED. TAP TO RETRY", "status-error");

            isProcessing = false;
            document.getElementById("finishBtn").disabled = false;

            document.getElementById("statusBanner").onclick = () => {
              document.getElementById("statusBanner").onclick = null;
              finishSession();
            };
          }
        }
      }
    }
  </script>
</body>
</html>
